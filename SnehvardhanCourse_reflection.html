<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Course Learning Reflections</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        h3 {
            margin-top: 20px;
        }
        ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        li {
            margin: 5px 0;
        }
        strong {
            color: #34495e;
        }
    </style>
</head>
<body>
    <h1><strong>Course Learning Reflections</strong></h1>
    <div>
        <h3>1. Problems in Nature (Iteration, Recursion, Backtracking)</h3>
        <ul>
            <li><strong>Iteration:</strong> Processes like the repetition of seasons, life cycles, or growth patterns represent iteration.</li>
            <li><strong>Recursion:</strong> Problems like calculating factorials or exploring decision trees demonstrate recursion.</li>
            <li><strong>Backtracking:</strong> Decision-making processes like maze-solving or predator-prey hunting paths illustrate backtracking.</li>
        </ul>

        <h3>2. Space and Time Efficiency</h3>
        <p>
            <strong>Space Efficiency:</strong> Refers to the memory usage of an algorithm.<br>
            <strong>Time Efficiency:</strong> Measures how fast an algorithm runs. Efficient algorithms handle large datasets effectively, ensuring timely responses.
        </p>
        <ul>
            <li><strong>Constant (O(1):</strong> Accessing an array element.</li>
            <li><strong>Logarithmic (O(log n):</strong> Binary search.</li>
            <li><strong>Linear (O(n):</strong> Iterating over a list.</li>
            <li><strong>Linearithmetic (O(nlogn):</strong> MergeSort, HeapSort.</li>
            <li><strong>Quadratic (O(n²):</strong> Nested loops.</li>
            <li><strong>Exponential (O(2ⁿ):</strong> Towers of Brahma.</li>
            <li><strong>Factorial (O(n!):</strong> N-Queens problem using brute force.</li>
        </ul>

        <h3>3. Takeaways from Different Design Principles</h3>
        <ul>
            <li><strong>Bubble Sort:</strong> Basic brute force algorithm for small datasets.</li>
            <li><strong>Merge Sort:</strong> Divide and conquer approach for large datasets.</li>
            <li><strong>Dijkstra's Algorithm:</strong> Finds shortest paths in weighted graphs.</li>
            <li><strong>Floyd's Algorithm:</strong> Computes all-pairs shortest paths in weighted graphs.</li>
        </ul>

        <h3>4. Hierarchical Data and Tree Structures</h3>
        <p>Hierarchical data organizes parent-child relationships, and trees represent such structures:</p>
        <ul>
            <li><strong>Binary Search Trees (BST):</strong> Quick search and insertions.</li>
            <li><strong>Heaps:</strong> Ideal for priority queues.</li>
            <li><strong>Tries:</strong> Efficient for prefix matching.</li>
        </ul>

        <h3>5. Array Query Algorithms</h3>
        <ul>
            <li><strong>Fenwick Tree:</strong> Efficient for range sum queries.</li>
            <li><strong>Segment Tree:</strong> Ideal for range sum and minimum queries.</li>
            <li><strong>Sparse Table:</strong> Efficient preprocessing for range queries.</li>
        </ul>

        <h3>6. Tree vs. Graph Traversals</h3>
        <ul>
            <li><strong>Tree Traversals:</strong> Linear within a hierarchy (e.g., In-order, Pre-order).</li>
            <li><strong>Graph Traversals:</strong> Explore paths with cycles (e.g., BFS, DFS).</li>
        </ul>

        <h3>7. Sorting and Searching Algorithms</h3>
        <ul>
            <li><strong>Merge Sort:</strong> Divide and conquer for large datasets.</li>
            <li><strong>Quick Sort:</strong> Efficient for diverse datasets.</li>
            <li><strong>Rabin-Karp:</strong> String search using hashing.</li>
        </ul>

        <h3>8. Importance of Graph Algorithms</h3>
        <ul>
            <li><strong>Spanning Trees:</strong> Prim's and Kruskal's algorithms minimize connection costs.</li>
            <li><strong>Shortest Paths:</strong> Dijkstra's and Bellman-Ford algorithms find optimal routes.</li>
        </ul>

        <h3>9. Algorithm Design Techniques</h3>
        <ul>
            <li><strong>Divide and Conquer:</strong> Breaks problems into sub-problems.</li>
            <li><strong>Dynamic Programming:</strong> Reuses solutions to overlapping sub-problems.</li>
            <li><strong>Greedy Algorithms:</strong> Makes locally optimal choices for global results.</li>
            <li><strong>Backtracking:</strong> Explores all possibilities systematically.</li>
        </ul>
    </div>
</body>
</html>
